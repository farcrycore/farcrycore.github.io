<item>
	<title>Reverse Proxy Caching and FarCry</title>
	<link>http://farcry.posterous.com/reverse-proxy-caching-and-farcry</link>
	<pubDate>Wed Jun 08 00:25:55 -0700 2011</pubDate>
	
	<dc:creator><![CDATA[Blair]]></dc:creator>
	
	
		<category domain="tag" nicename="caching"><![CDATA[caching]]></category>
	
		<category domain="tag" nicename="reverseproxy"><![CDATA[reverseproxy]]></category>
	

	<category><![CDATA[Uncategorized]]></category>

	<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>

  <guid isPermaLink="false">http://farcry.posterous.com/reverse-proxy-caching-and-farcry</guid>
	<description></description>
	<content:encoded><![CDATA[FarCry already has various mechanisms for caching content. These make it easy to do things like cache some parts of a page and not others, have different timeouts for each, automatically expire caches if content changes, and so on. This is possible because the cache is managed in memory on the same server where the data is edited by administrators, and the HTML is generated by FarCry.<p /> Where FarCry caching is a sophisticated and granular caching solution, a reverse proxy (RP) is the &quot;big hammer&quot; solution. One for complex and highly dynamic content, the other for overwhelming traffic and mostly static content.<p /> Thus controlling RP caching is a different beast. It is simple and unwieldy, because it needs to perform well under high load. It is possible to create complicated caching strategies with an RP like Varnish, but we have gone with a simpler approach:<br /> <ul><li>cache based on the s-maxage header in backend responses<br /></li><li>clear a site&#39;s entire cache on GET /varnishpurge from an authorised IP address</li></ul><br />This moves control of which pages get cached and for how long back to FarCry. But this is still fundamentally different to FarCry&#39;s internal caching options:<br /> <ul><li>page caching strategy VS fragment caching strategy<br /></li><li>cache refreshed on timeout VS refresh on timeout, or content change<br /></li><li>cache by URL (and to a lesser extent cookies and user agent) VS cache by URL, form, user role, custom variables</li> </ul><br />Because of this we decided that it didn&#39;t make sense to try to extrapolate the RP cache timeout based on a projects existing config. Instead we added support for a new webskin decorator: @@proxyCacheTimeout [<a href="https://farcry.jira.com/wiki/display/FCDEV60/Cache+Headers" target="_blank" style="color: #3465A4;">https://farcry.jira.com/wiki/display/FCDEV60/Cache+Headers</a>]. This means developers will need to consciously decide which pages to cache and for how long.  ]]></content:encoded>
	<excerpt:encoded><![CDATA[FarCry already has various mechanisms for caching content. These make it easy to do things like cache some parts of a page and not others, have different timeouts for each, automatically expire caches if content changes, and so on. This is possibl...]]></excerpt:encoded>	

	<wp:post_date>Wed Jun 08 00:25:55 -0700 2011</wp:post_date>
	<wp:post_date_gmt>%= display_date %></wp:post_date_gmt>
	<wp:comment_status>open</wp:comment_status>
	<wp:ping_status>open</wp:ping_status>
	<wp:post_name>reverse-proxy-caching-and-farcry</wp:post_name>
	<wp:status>publish</wp:status>
	<wp:post_parent>0</wp:post_parent>
	<wp:menu_order>0</wp:menu_order>
	<wp:post_type>post</wp:post_type>
	<wp:post_password></wp:post_password>
	<wp:is_sticky>0</wp:is_sticky>

	
		<wp:comment>
			<!-- <wp:comment_id>5</wp:comment_id> -->
			<wp:comment_author><![CDATA[Geoffrey Bowers]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_date>Sun Jul 31 20:34:27 -0700 2011</wp:comment_date>
			<wp:comment_date_gmt>Sun Jul 31 20:34:27 -0700 2011</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[A great real world example of this reverse proxy magic in action is here:
http://www.adnews.com.au/]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
		</wp:comment>
	
</item>
