<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<link href='../../../exports.css' rel='stylesheet'>
<link href='../../../exports.css' rel='stylesheet'>

</head>
<body>
<div id='wrap'>
<div id='header'>
<h1>farcry cms</h1>
<h2>This is an archived post
This is an archived post
</h2>
</div>
<div id='content'><div id='nav'>
<a href="../../../posts/2011/07/google-analytics-plugin-released.html">Previous</a>
&nbsp; 
<a href="../../../index-2.html">Index</a>
&nbsp; 
<a href="../../../posts/2011/04/farcry-running-railo-in-cloudbees.html">Next</a>
</div>
<div class='post'>
<div class='post_header'>
<h3>Reverse Proxy Caching and FarCry</h3>
<div class='post_info'>
<span class='post_time'>June  8 2011, 12:25 AM</span>
<span class='author'>&nbsp;by Blair</span>
</div>
</div>
<div class='post_body'>FarCry already has various mechanisms for caching content. These make it easy to do things like cache some parts of a page and not others, have different timeouts for each, automatically expire caches if content changes, and so on. This is possible because the cache is managed in memory on the same server where the data is edited by administrators, and the HTML is generated by FarCry.<p /> Where FarCry caching is a sophisticated and granular caching solution, a reverse proxy (RP) is the &quot;big hammer&quot; solution. One for complex and highly dynamic content, the other for overwhelming traffic and mostly static content.<p /> Thus controlling RP caching is a different beast. It is simple and unwieldy, because it needs to perform well under high load. It is possible to create complicated caching strategies with an RP like Varnish, but we have gone with a simpler approach:<br /> <ul><li>cache based on the s-maxage header in backend responses<br /></li><li>clear a site&#39;s entire cache on GET /varnishpurge from an authorised IP address</li></ul><br />This moves control of which pages get cached and for how long back to FarCry. But this is still fundamentally different to FarCry&#39;s internal caching options:<br /> <ul><li>page caching strategy VS fragment caching strategy<br /></li><li>cache refreshed on timeout VS refresh on timeout, or content change<br /></li><li>cache by URL (and to a lesser extent cookies and user agent) VS cache by URL, form, user role, custom variables</li> </ul><br />Because of this we decided that it didn&#39;t make sense to try to extrapolate the RP cache timeout based on a projects existing config. Instead we added support for a new webskin decorator: @@proxyCacheTimeout [<a href="https://farcry.jira.com/wiki/display/FCDEV60/Cache+Headers" target="_blank" style="color: #3465A4;">https://farcry.jira.com/wiki/display/FCDEV60/Cache+Headers</a>]. This means developers will need to consciously decide which pages to cache and for how long.  </div>
<div class='post_tags'>
<h4>Tags</h4>
<div class='post_tags_list'>caching, reverseproxy</div>
</div>
<div class='post_responses'>
<h4>686 views and 1 response</h4>
<ul class='post_responses list'>
<li class='response clearfix'>
<div class='response_header'>
<div class='response_time'>Jul 31 2011,  8:34 PM</div>
<div class='response_name'>Geoffrey Bowers (Facebook) responded:</div>
</div>
<div class='response_body'>A great real world example of this reverse proxy magic in action is here:<br /><a href="http://www.adnews.com.au/" rel="nofollow">http://www.adnews.com.au/</a></div>
</li>
</ul>
</div>
</div>
</div>
</div>
</body>
</html>
